//require('backend/functions.js');
// creates an unique id
function createUUID() {
    // http://www.ietf.org/rfc/rfc4122.txt
    var s = [];
    var hexDigits = "0123456789abcdef";
    for (var i = 0; i < 36; i++) {
           s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }
    // bits 12-15 of the time_hi_and_version field to 0010
    s[14] = "4";
    // bits 6-7 of the clock_seq_hi_and_reserved to 01  
    s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
    s[8] = s[13] = s[18] = s[23] = "-";

    var uuid = s.join("");
    return uuid;
};
var Filter = require('backend/Filter.js');

FilterManager = function (dbaccess) {
    var _that = this;
    
    var DBAccess = dbaccess;
    var _collectionName = 'filter';
    
    var ticketCollectionKeyNames = [{keyName: 'ticketID'}, {keyName: 'ticketTitle'}, {keyName: 'ticketDescription'}, {keyName: 'ticketTyp'}, {keyName: 'ticketPriority'}, {keyName: 'ticketDueDate'}, {keyName: 'ticketProjektID'}, {keyName: 'ticketUserID'}, {keyName: 'ticketCreationDate'}];
//    DBAccess.getCollectionKeyNames('ticket', function (resultDBAccess) {
//        if (resultDBAccess.errorDBAccess == undefined && resultDBAccess.length > 0) {
//            ticketCollectionKeyNames = resultDBAccess;
//        }
//        else {
//            console.log('FM: Fatal Error on getCollectionKeyNames in FilterManager');
//        }
//    });
    
    this.getFiltersAsButtons = function (params, res, controllerCallback) {
        _that.findFilters(params, res, function (resultDBAccess, res) {
            var htmlStrings = [];
            
            for (var i = 0; i < resultDBAccess.length; i++) {
                var filterFunctionValue;
                if (resultDBAccess[i].filterFunction == 'include') {
                    filterFunctionValue = '=';
                }
                else {
                    filterFunctionValue = '!=';
                }
                htmlStrings[i] = '<input id="' + resultDBAccess[i]._id + '" type="button" class="btn btn-default" value ="' + resultDBAccess[i].filterFieldName + ' ' + filterFunctionValue + ' ' + resultDBAccess[i].filterValue + '">';
            }
            
            controllerCallback(htmlStrings, res);
        });
    };
    
    this.getFilter = function (params, res, controllerCallback) {
        if (typeof params.filterID == 'string') {
            DBAccess.readDataset(_collectionName, params, function (resultDBAccess) {
                if (resultDBAccess.errorDBAccess == undefined && resultDBAccess.length > 0) {
                    controllerCallback(resultDBAccess[0], res);
                }
                else {
                    controllerCallback('FM: ERROR Filter not found', res);
                }
            });
        }
        else {
            controllerCallback('FM: ERROR invalid params', res);
        }
    };
    
    this.findFilters = function (params, res, controllerCallback) {
        // this is stupid, more than that, there is no filter arttribute at any time so have to proof if params has "any" attribute
//        if (params.filterID == undefined) {
            var emptyObj = {};
            DBAccess.readDataset(_collectionName, emptyObj, function (resultDBAccess) {
                controllerCallback(resultDBAccess, res);
            });
//        }
    };
    
    this.createFilter = function (params, res, controllerCallback) {
        if ((typeof params.filterValue == 'string' || typeof params.filterValue == 'number' || typeof params.filterValue == 'boolean') && typeof params.filterFunction == 'string' && typeof params.filterFieldName == 'string') {
            params.filterID = createUUID();
            // maybe you could wrote a function to get collectionName from fieldName
//            var collectionName;
//            if (params.filterFieldName.ind)
            if (ticketCollectionKeyNames.length > 0) {
                for (var i = 0; i < ticketCollectionKeyNames.length; i++) {
                    console.log(i + '. loop with keyName: ', ticketCollectionKeyNames[i].keyName, ' and passed fieldName: ', params.filterFieldName);
                    if (ticketCollectionKeyNames[i].keyName == params.filterFieldName) {
                        DBAccess.createDataset(_collectionName, params, function (resultDBAccess) {
                            if (resultDBAccess.errorDBAccess == undefined) {
                                if (params.filterID != undefined) {
                                    var responseIDParams = {
                                        filterID: params.filterID
                                    };

                                    controllerCallback(responseIDParams, res);
                                }
                                else {
                                    controllerCallback('FM: ERROR filterID is undefined after createDataset in createFilter();', res);
                                }
                            }
                            else {
                                controllerCallback('FM: ERROR on createDataset in createFilter();' + resultDBAccess.errorDBAccess, res);
                            }
                        });
                    }
                    else if (i == ticketCollectionKeyNames.length) {
                        controllerCallback('FM: ERROR filterFieldName is not a valid key-name of the collection', res);
                    }
                }
            }
            else {
                controllerCallback('FM: Fatal ERROR on createFilter() ticketCollectionKeyNames array is empty', res);
            }
        }
        else {
            controllerCallback('FM: ERROR invalid params', res);
        }
    };
    
    this.updateFilter = function (params, res, controllerCallback) {
        if (typeof params.filterID == 'string') {
            DBAccess.updateDataset(_collectionName, params, function (resultDBAccess) {
                if (resultDBAccess.errorDBAccess == undefined) {
                    controllerCallback(resultDBAccess, res);
                }
                else {
                    controllerCallback('FM: ERROR on updateDataset in updateFilter();' + resultDBAccess.errorDBAccess, res);
                }
            });
        }
        else {
            controllerCallback('FM: ERROR invalid params', res);
        }
    };
    
    this.removeFilter = function (params, res, controllerCallback) {
        if (typeof params.filterID == 'string') {
            DBAccess.removeDataset(_collectionName, params, function (resultDBAccess) {
                if (resultDBAccess.errorDBAccess == undefined) {
                    controllerCallback(resultDBAccess, res);
                }
                else {
                    controllerCallback('FM: ERROR on removeDataset in removeFilter();' + resultDBAccess.errorDBAccess, res);
                }
            });
        }
        else {
            controllerCallback('FM: ERROR invalid params', res);
        }
    };
};

//check if nodejs is running this code
try {
    module.exports = function () {
        return FilterManager;
    }();
} catch (e) {

}


