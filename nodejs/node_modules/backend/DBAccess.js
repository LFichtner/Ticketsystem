DBAccess = function (mongodb) {
    var _that = this;
    
    //We need to work with "MongoClient" interface in order to connect to a mongodb server.
    var MongoClient = mongodb.MongoClient;
    
//    var DB_NAME = 'dbTest';
//    var DB_NAME = 'Ticketsystem';
    var DB_NAME = 'IHK';
    var DB_URL = 'mongodb://127.0.0.1:27017/' + DB_NAME;
    
    // 
    /*
     * id have to be reached to DB as "_id" and not like "userID" or "ticketID" so its converted in this method
     * 
     * @param {Object|Array} params
     * @returns {unresolved}
     */
    var updateParamsIDName = function (params) {
        if (params.ticketID) {
            params._id = params.ticketID;
            delete params.ticketID;
        }
        else if (params.filterID) {
            params._id = params.filterID;
            delete params.filterID;
        }
        else if (params.userID) {
            params._id = params.userID;
            delete params.userID;
        }
        else if (params.projektID) {
            params._id = params.projektID;
            delete params.projektID;
        }

        return params;
    };
    
    // id name have to be known in order to revert params obj after process
    var getParamsIDName = function (params) {
        if (params.ticketID) {
            return 'ticketID';
        }
        else if (params.filterID) {
            return 'filterID';
        }
        else if (params.userID) {
            return 'userID';
        }
        else if (params.projektID) {
            return 'projektID';
        }
    };
    
    // id name have to be known in order to revert params obj after process
    var revertParamsIDName = function (params, IDName) {
        params[IDName] = params._id;
//        console.log(params[IDName]);
        delete params._id;
        return params;
    };
    
    // methode callback reach control back to called DBAccess-Methode after Connection was init
    // classCallback reach control back to the Class which called the DBAccess-Methode
    // closeConnectionCallback is located in the function defined in this methode and reach the control back to it after the work is done and the connection can be closed
    var Connect = function (methodeCallback) {
        // Use connect method to connect to the Server
        MongoClient.connect(DB_URL, function (errorDBAccess, db) {
            if (errorDBAccess) {
                console.log('DBA: ERROR Unable to connect to the mongoDB server. Error:', errorDBAccess);
            } else {
                //HURRAY!! We are connected. :)
                console.log('DBA: Connection established to', DB_URL);
                
                methodeCallback(db, function (classCallback, result) {
                    // always close connection
                    db.close();
                    
                    if (classCallback) {
                        classCallback(result);
                    }
                });                
            }
        });
    };
    
    // drops the database
    this.clearDatabase = function (classCallback) {
        Connect(function (db, closeConnectionCallback) {
            db.dropDatabase(function (errorDBAccess, result) {
                if (errorDBAccess != null) {
                    console.log('DBA: Error on clearDatabase: ', errorDBAccess);
                    var errorResultObj = {
                        errorDBAccess: errorDBAccess
                    };
                    closeConnectionCallback(classCallback, errorResultObj);
                }
                else {
                    console.log('DBA: Dropped Database: ', DB_NAME);
                    closeConnectionCallback(classCallback, errorDBAccess);
                }
            });
        });
    };
    
    this.getCollectionKeyNames = function (collectionName, params, classCallback) {
        mr = db.runCommand({
            "mapreduce": "ticket",
            "map": function () {
                for (var key in this) {
                    emit(key, null);
                }
            },
            "reduce": function (key, stuff) {
                return null;
            },
            "out": "ticket" + "_keys"
        });
        db[mr.result].distinct("_id");
    }

    this.createDataset = function (collectionName, params, classCallback) {
        var IDName = getParamsIDName(params);
        if (params.length != undefined) {
            for (var i = 0; i < params.length; i++) {
                params[i] = updateParamsIDName(params[i]);
            }
        }
        else {
            params = updateParamsIDName(params);
        }
        
        Connect(function(db, closeConnectionCallback) {
            var collection = db.collection(collectionName);
            
            collection.insert(params, function (errorDBAccess, result) {
                revertParamsIDName(params, IDName);
                if (errorDBAccess != null) {
                    console.log('DBA: ERROR on createDataset: ', errorDBAccess);
                    var errorResultObj = {
                        errorDBAccess: errorDBAccess
                    };
                    
                    closeConnectionCallback(classCallback, errorResultObj);
                } 
                else {
                    console.log('DBA: Inserted %d documents into the ' + collectionName +' collection. The documents inserted with "_id" may stand here:'/*, result.length, result*/);
                    var successResultObj = {
                        result: true
                    };
                    
                    closeConnectionCallback(classCallback, successResultObj);
                }
            });
        });
    };
    
    this.updateDataset = function (collectionName, params, classCallback) {
        var IDName = getParamsIDName(params);
        if (params.length != undefined) {
            for (var i = 0; i < params.length; i++) {
                params[i] = updateParamsIDName(params[i]);
            }
        }
        else {
            params = updateParamsIDName(params);
        }
        
        Connect(function(db, closeConnectionCallback) {
            var collection = db.collection(collectionName);
//            console.log('================================================================================');
//            console.log('params: ', params);
//            console.log('params._id: ', params._id);
//            console.log('================================================================================');
            collection.update({_id: params._id}, {$set: params}, function (errorDBAccess, result) {
                revertParamsIDName(params, IDName);
                if (errorDBAccess != null) {
                    console.log('DBA: ERROR on updateDataset: ', errorDBAccess);
                    var errorResultObj = {
                        errorDBAccess: errorDBAccess
                    };
                    
                    closeConnectionCallback(classCallback, errorResultObj);
                } 
                else {
                    console.log('DBA: Saved %d documents into the ' + collectionName +' collection. The documents inserted with "_id" may stand here:'/*, result.length, result*/);
                    var successResultObj = {
                        result: true
                    };
                    
                    closeConnectionCallback(classCallback, successResultObj);
                }
            });
        });
    };
    
    this.removeDataset = function (collectionName, params, classCallback) {
        var IDName = getParamsIDName(params);
        if (params.length != undefined) {
            for (var i = 0; i < params.length; i++) {
                params[i] = updateParamsIDName(params[i]);
            }
        }
        else {
            params = updateParamsIDName(params);
        }
        
        Connect(function(db, closeConnectionCallback) {
            var collection = db.collection(collectionName);
            
            collection.remove(params, function (errorDBAccess, result) {
                revertParamsIDName(params, IDName);
                if (errorDBAccess != null) {
                    console.log('DBA: ERROR on removeDataset: ', errorDBAccess);
                    var errorResultObj = {
                        errorDBAccess: errorDBAccess
                    };
                    
                    closeConnectionCallback(classCallback, errorResultObj);
                } 
                else {
                    console.log('DBA: Removed %d documents in the ' + collectionName +' collection. The documents removed with "_id" may stand here:'/*, result.length, result*/);
                    var successResultObj = {
                        result: true
                    };
                    
                    closeConnectionCallback(classCallback, successResultObj);
                }
            });
        });
    };
    
    this.readDataset = function (collectionName, params, classCallback, exclude) {
        var IDName;
//        console.log('params in readDataset: ', params);
        // TODO howto proof for empty object
        if (params) {
            IDName = getParamsIDName(params);
            if (params.length != undefined) {
                for (var i = 0; i < params.length; i++) {
                    params[i] = updateParamsIDName(params[i]);
                }
            }
            else {
                params = updateParamsIDName(params);
            }
        }
//        console.log('params in readDataset: ', params);
        Connect(function(db, closeConnectionCallback) {
            var collection = db.collection(collectionName);
            
            var localCallback = function (errorDBAccess, resultArray) {
                if (IDName) {
                    revertParamsIDName(params, IDName);
                }
                if (errorDBAccess != null) {
                    console.log('DBA: ERROR on findDataset: ', errorDBAccess);
                    var errorResultObj = {
                        errorDBAccess: errorDBAccess
                    };
                    
                    closeConnectionCallback(classCallback, errorResultObj);
                }
                else {
                    console.log('DBA: Read data in ' + collectionName +' collection. The documents read with "_id" may stand here:'/*, resultArray.length, resultArray*/);
                    
                    closeConnectionCallback(classCallback, resultArray);
                }
            };
            
            if (exclude == true) {
                collection.find(params).toArray(function (errorDBAccess, resultArray) {
                    localCallback(errorDBAccess, resultArray);
                });
            }
            else {
                collection.find(params).toArray(function (errorDBAccess, resultArray) {
                    localCallback(errorDBAccess, resultArray);
                });
            }
        });
    };
};

//check if nodejs is running this code
try {
    module.exports = function () {
        return DBAccess;
    }();
} catch (e) {

}

////check if nodejs is running this code
//try {
//    module.exports = function (jQuery, localConfiguration, btoa, funcs) {
//        return new MykeneNS.JadeManagerNS.JadeManager(jQuery, localConfiguration, btoa, funcs);
//    };
//} catch (e) {
//
//}